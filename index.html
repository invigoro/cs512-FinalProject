<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <title>UNM CS 412/512 Final Project</title>
  <style>
    body {
      background: #111;
      color: #ccc;
      font-family: monospace;
    }

    textarea {
      background: #222;
      color: #0f0;
      font: 14px monospace;
      width: 400px;
      height: 250px;
    }

    canvas {
      border: 1px solid #444444;
      background: #71afee;

    }
    button {
      font-size: 24px;


    }
  </style>
  <link rel="icon" type="image/x-icon" href="./img/favico.png">
</head>

<body>
<div style="display: flex; justify-content: center; gap: 10px; align-items: flex-start;">
  <div>
    <canvas id="glcanvas" width="1200" height="800"></canvas>
    <div style="display: flex; justify-content: space-between; width: 1200px; font-size: 24px;">
      <div>
        <div id="levelCounter">Level: 1</div>
        <div id="ballCounter">Balls: 0/0</div>
      </div>
      <div style="margin-top: 20px; text-align: center;">
  Try it yourself! <b>tinyurl.com/Finalcs512</b><br>
  Or view the <a href="https://github.com/invigoro/cs512-FinalProject">source code</a>
</div>
      <div>
        <div id="Timer">Time: 45s<br> </div>
        <button id="restartBtn">Restart</button>
      </div>
    </div>
      
  </div>

</div>



  <!-- Vertex shader -->
  <script id="vertex-shader" type="x-shader/x-vertex">#version 300 es
precision mediump float;

in vec3 aPosition;
in vec3 aNormal;
in vec3 aColor;
in vec2 aTexCoord;

uniform mat4 uModelViewMatrix;
uniform mat4 uProjectionMatrix;
uniform mat4 uModelTransformationMatrix;
uniform mat3 uNormalMatrix;

out vec3 vColor;
out vec3 vNormal;
out vec3 vPosition;
out vec2 vTexCoord;

void main() {
    vec4 worldPos = uModelTransformationMatrix * vec4(aPosition, 1.0);

    gl_Position = uProjectionMatrix * uModelViewMatrix * worldPos;

    vColor = aColor;
    vNormal = normalize(uNormalMatrix * aNormal);
    vPosition = worldPos.xyz;
    vTexCoord = aTexCoord;
}
</script>
  <!-- Fragment Shader -->
  <script id="fragment-shader" type="x-shader/x-fragment">#version 300 es
precision mediump float;

in vec3 vColor;
in vec3 vNormal;
in vec3 vPosition;
in vec2 vTexCoord;

out vec4 fragColor;

// Directional light
uniform vec3 uLightDir;  
uniform vec3 uLightColor;

// Material data
uniform float uKAmbient;
uniform float uKDiffuse;
uniform float uKSpecular;
uniform float uShininess;

uniform sampler2D uTex;
uniform sampler2D uBumpTex;
uniform bool uUseBump;
uniform float uBumpStrength;
uniform bool uUseTexture;

void main() {
    vec3 N = normalize(vNormal);
    if (uUseBump) {
        float h  = texture(uBumpTex, vTexCoord).r;
        float hu = texture(uBumpTex, vTexCoord + vec2(0.01, 0.0)).r;
        float hv = texture(uBumpTex, vTexCoord + vec2(0.0, 0.01)).r;

        vec3 grad = vec3((h - hu) * uBumpStrength,
                         (h - hv) * uBumpStrength,
                          1.0);

        N = normalize(N + grad);
    }

    // Directional light same L for entire scene
    vec3 L = normalize(-uLightDir); 
    vec3 V = normalize(-vPosition);
    vec3 H = normalize(L);

    float diff = max(dot(N, L), 0.0);

    float spec = 0.0;
    if (diff > 0.0) {
        spec = pow(max(dot(N, H), 0.0), uShininess);
    }

    vec3 ambient  = uKAmbient  * vColor;
    vec3 diffuse  = uKDiffuse  * diff * vColor;
    vec3 specular = uKSpecular * spec * uLightColor;

    vec3 texColor = vec3(1.0);
    if (uUseTexture) {
        texColor = texture(uTex, vTexCoord).rgb;
    }

    vec3 result = 1.6 * (ambient + diffuse) * texColor + specular;
    fragColor = vec4(result, 1.0);
}
</script>


  <!-- Debug Line Vertex Shader -->
  <!-- <script id="line-vertex-shader" type="x-shader/x-vertex">#version 300 es
precision mediump float;

in vec3 aPosition;

uniform mat4 uModelViewMatrix;
uniform mat4 uProjectionMatrix;

void main() {
    gl_Position = uProjectionMatrix * uModelViewMatrix * vec4(aPosition, 1.0);
}
</script> -->

  <!-- Debug Line Fragment Shader -->
  <!-- <script id="line-fragment-shader" type="x-shader/x-fragment">#version 300 es
precision mediump float;

uniform vec3 uDebugColor;
out vec4 fragColor;

void main() {
    fragColor = vec4(uDebugColor, 1.0);
}
</script> -->

  <script src="utility.js"></script>
  <script src="collider.js"></script>
  <script src="particles.js"></script>
  <script src="primitives.js"></script>
  <script src="transformation.js"></script>
  <script src="sceneObjects.js"></script>

  <script>
    let currentLevel = 1;
    createScene(currentLevel);
    function createShader(gl, type, source) {
      let shader = gl.createShader(type);
      gl.shaderSource(shader, source);
      gl.compileShader(shader);
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        throw new Error(gl.getShaderInfoLog(shader));
      }
      return shader;
    }

    function createProgram(gl, vsSource, fsSource) {
      let vs = createShader(gl, gl.VERTEX_SHADER, vsSource);
      let fs = createShader(gl, gl.FRAGMENT_SHADER, fsSource);
      let prog = gl.createProgram();
      gl.attachShader(prog, vs);
      gl.attachShader(prog, fs);
      gl.linkProgram(prog);
      if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
        throw new Error(gl.getProgramInfoLog(prog));
      }
      return prog;
    }

    // WebGL setup
    const canvas = document.getElementById("glcanvas");
    const gl = canvas.getContext("webgl2");
    if (!gl) alert("WebGL2 not supported");



    let program, posLoc, colorLoc, normalLoc, texCoordLoc;
    let uMVM, uPM, uMTM, uNormalMatrix;
    let uLightDir;
    let uKAmbient, uKDiffuse, uKSpecular, uKShininess;
    let uUseTexture;
    let uUseBump, uBumpTex, uBumpStrength;


    // Debug line program
    let lineProgram, linePosLoc, lineUMVM, lineUPM, lineUDebugColor;
    let lineVAO, lineVBO;

    //BALLS
    let maxballs = ballColliders.length;
    let currentballs = maxballs;


    let vbo, cbo, nbo, ibo;
    let gameTime = 45;
    let lastTime = Date.now();

    // Buffers
    function initBuffers() {
      vbo = gl.createBuffer();
      cbo = gl.createBuffer();
      nbo = gl.createBuffer();
      ibo = gl.createBuffer();
    }
    initBuffers();

    function initShaderProgram() {
      try {
        program = createProgram(gl, document.getElementById("vertex-shader").textContent, document.getElementById("fragment-shader").textContent);
        gl.useProgram(program);
        posLoc = gl.getAttribLocation(program, "aPosition");
        colorLoc = gl.getAttribLocation(program, "aColor");
        timeLoc = gl.getUniformLocation(program, "uTime");
        uMVM = gl.getUniformLocation(program, "uModelViewMatrix");
        uPM = gl.getUniformLocation(program, "uProjectionMatrix");
        uMTM = gl.getUniformLocation(program, "uModelTransformationMatrix");

        normalLoc = gl.getAttribLocation(program, "aNormal");
        texCoordLoc = gl.getAttribLocation(program, "aTexCoord");

        uNormalMatrix = gl.getUniformLocation(program, "uNormalMatrix");
        uLightDir = gl.getUniformLocation(program, "uLightDir")
        uViewPos = gl.getUniformLocation(program, "uViewPos");
        uLightColor = gl.getUniformLocation(program, "uLightColor");

        uKAmbient = gl.getUniformLocation(program, "uKAmbient");
        uKDiffuse = gl.getUniformLocation(program, "uKDiffuse");
        uKSpecular = gl.getUniformLocation(program, "uKSpecular");
        uShininess = gl.getUniformLocation(program, "uShininess");

        uUseTexture = gl.getUniformLocation(program, "uUseTexture");
        uUseBump = gl.getUniformLocation(program, "uUseBump");
        uBumpTex = gl.getUniformLocation(program, "uBumpTex");
        uBumpStrength = gl.getUniformLocation(program, "uBumpStrength");
        uTex = gl.getUniformLocation(program, "uTex");

        // // Initialize line program
        // lineProgram = createProgram(gl, 
        //   document.getElementById("line-vertex-shader").textContent,
        //   document.getElementById("line-fragment-shader").textContent);
        // linePosLoc = gl.getAttribLocation(lineProgram, "aPosition");
        // lineUMVM = gl.getUniformLocation(lineProgram, "uModelViewMatrix");
        // lineUPM = gl.getUniformLocation(lineProgram, "uProjectionMatrix");
        // lineUDebugColor = gl.getUniformLocation(lineProgram, "uDebugColor");

        // // Create line VAO
        // lineVAO = gl.createVertexArray();
        // lineVBO = gl.createBuffer();

      } catch (e) { console.error(e); }
    }
    initShaderProgram();


    //surface colliders
    let onRoad = false;
    let onMud = false;
    // Kart physics
    let kartX = 0, kartZ = 0, kartAngle = 0, kartSpeed = 0;
    let freezeCar = false;
    const maxSpeed = 1;
    const maxSpeedMud = 0.6;
    const maxSpeedRoad = 1.3;
    const acceleration = 0.035;
    const accelerationMud = 0.03;
    const accelerationRoad = 0.06;
    const friction = 0.95;
    const frictionMud = 0.9;
    const frictionRoad = .97;
    const turnSpeed = 0.05;
    let isTurning = 0;
    const axleTurnCoeff = 3.0;
    let steeringInput = 0.0;     // -1 .. 1 from player
    let steeringAngle = 0.0;     
    const maxSteerAngle = 0.6; // rad (~30 deg)
    const steerResponsiveness = 1; // smoothing speed
    const burnoutSpeed = 0.8;

    
    function getMaxSpeed() {
      if(freezeCar) return 0;
      if(onRoad) return maxSpeedRoad;
      if(onMud) return maxSpeedMud;
      return maxSpeed;
    }
    function getAcceleration() {
      if(onRoad) return accelerationRoad;
      if(onMud) return accelerationMud;
      return acceleration;
    }
    function getFriction() {
      if(onRoad) return frictionRoad;
      if(onMud) return frictionMud;
      return friction;
    }

    // Keyboard
    let keys = {};
    document.addEventListener('keydown', e => {
      keys[e.key] = true;
      if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) e.preventDefault();
    });
    document.addEventListener('keyup', e => keys[e.key] = false);

    let fov = Math.PI / 4, aspect = canvas.width / canvas.height, zNear = 0.1, zFar = 1000;
    let f = 1 / Math.tan(fov / 2);
    let proj = new Float32Array([
      f / aspect, 0, 0, 0, 0, f, 0, 0, 0, 0, (zFar + zNear) / (zNear - zFar), -1, 0, 0, (2 * zFar * zNear) / (zNear - zFar), 0
    ]);

    let startTime = Date.now();

    function loadTexture(url) {
      if(loadedImages[url]) { 
        return loadedImages[url];
      }
      let texture = gl.createTexture();
      
      let image = new Image();
      image.crossOrigin = "anonymous";
      image.onload = () => {
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
        gl.generateMipmap(gl.TEXTURE_2D);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
      };
      image.src = url;

      loadedImages[url] = texture;
      return texture;
    }

function drawPrimitive(prim, transform = null) {
  let yPos = prim.posY;
  if(prim.yAnimDist > 0 && prim.yAnimSpeed > 0) {
    yPos += Math.sin((Date.now() - startTime) / prim.yAnimSpeed) * prim.yAnimDist; 
  }
  let T = mat4Translate(mat4Identity(), [prim.posX, yPos, prim.posZ]);
  let R = prim.getRotationMatrix();
  let S = mat4Scale(mat4Identity(), [prim.scaX, prim.scaY, prim.scaZ]);
  let localTransform = multiplyMat4(multiplyMat4(T, R), S);
  transform = transform ?? mat4Identity();
  transform = multiplyMat4(transform, localTransform);
  
  if (prim.collider) {
    prim.collider.updateParentTransform(transform);
  }


  gl.bindVertexArray(prim.vao);
  


  gl.uniformMatrix4fv(uMTM, false, transform);
  
  let normalMatrix = mat3FromMat4(transform);
  normalMatrix = mat3InvertTranspose(normalMatrix);
  gl.uniformMatrix3fv(uNormalMatrix, false, normalMatrix);


  gl.uniform1f(uKAmbient, prim.kAmbient);
  gl.uniform1f(uKDiffuse, prim.kDiffuse);
  gl.uniform1f(uKSpecular, prim.kSpecular);
  gl.uniform1f(uShininess, prim.shininess);

  if (prim.hasTexture) {
    if (!prim.texture)
      prim.texture = loadTexture(prim.textureUrl);
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, prim.texture);
    gl.uniform1i(uUseTexture, 1);
    gl.uniform1i(uTex, 0);
  } else {
    gl.uniform1i(uUseTexture, 0);
  }

  if (prim.hasBump) {
    if (!prim.bumpTexture)
      prim.bumpTexture = loadTexture(prim.bumpTextureUrl);
    gl.activeTexture(gl.TEXTURE1);
    gl.bindTexture(gl.TEXTURE_2D, prim.bumpTexture);
    gl.uniform1i(uUseBump, 1);
    gl.uniform1i(uBumpTex, 1);
    gl.uniform1f(uBumpStrength, prim.bumpStrength);
  } else {
    gl.uniform1i(uUseBump, 0);
  }

  gl.drawElements(gl.TRIANGLES, prim.indices.length, gl.UNSIGNED_SHORT, 0);

  prim.children.forEach(child => drawPrimitive(child, transform));
  prim.particles.forEach(part => {
    part.update(renderTime);
      //if(!part.isDisabled) 
    part.particles.forEach(p => {
      drawPrimitive(p.obj, transform);
    })
  })
}

    // Draw collider debug visualization
    function drawColliderDebug(collider, color = [0, 1, 0]) {
      if (!collider.points) return;

      // Create line segments for the 12 edges of a cube
      const edges = [
        // Bottom face
        [0, 1], [1, 2], [2, 3], [3, 0],
        // Top face
        [4, 5], [5, 6], [6, 7], [7, 4],
        // Vertical edges
        [0, 4], [1, 5], [2, 6], [3, 7]
      ];

      const vertices = [];
      for (const [i, j] of edges) {
        vertices.push(...collider.points[i]);
        vertices.push(...collider.points[j]);
      }

      gl.useProgram(lineProgram);
      gl.bindVertexArray(lineVAO);
      
      gl.bindBuffer(gl.ARRAY_BUFFER, lineVBO);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.DYNAMIC_DRAW);
      
      gl.enableVertexAttribArray(linePosLoc);
      gl.vertexAttribPointer(linePosLoc, 3, gl.FLOAT, false, 0, 0);

      gl.uniformMatrix4fv(lineUPM, false, proj);
      gl.uniformMatrix4fv(lineUMVM, false, modelViewMatrix);
      gl.uniform3fv(lineUDebugColor, color);

      gl.drawArrays(gl.LINES, 0, vertices.length / 3);

      // Switch back to main program
      gl.useProgram(program);
    }

    let wheelRotation = 0;


    function createVAO(prim) {
  const vao = gl.createVertexArray();
  gl.bindVertexArray(vao);

  // Position buffer
  const posBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, posBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, prim.positions, gl.STATIC_DRAW);
  gl.enableVertexAttribArray(posLoc);
  gl.vertexAttribPointer(posLoc, 3, gl.FLOAT, false, 0, 0);

  // Normal buffer
  const normalBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, prim.normals, gl.STATIC_DRAW);
  gl.enableVertexAttribArray(normalLoc);
  gl.vertexAttribPointer(normalLoc, 3, gl.FLOAT, false, 0, 0);

  // Color buffer
  const colorBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, prim.colors, gl.STATIC_DRAW);
  gl.enableVertexAttribArray(colorLoc);
  gl.vertexAttribPointer(colorLoc, 3, gl.FLOAT, false, 0, 0);

  // Texture coordinates
  if (prim.hasTexture||prim.hasBump) {
    const texBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, texBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, prim.texCoords, gl.STATIC_DRAW);
    gl.enableVertexAttribArray(texCoordLoc);
    gl.vertexAttribPointer(texCoordLoc, 2, gl.FLOAT, false, 0, 0);
  }
  // Index buffer
  const indexBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, prim.indices, gl.STATIC_DRAW);

  gl.bindVertexArray(null);
  
  return vao;
}

function initAllVAOs(prim) {
  if (!prim.vao) {
    prim.vao = createVAO(prim);
    
if (prim.hasTexture) {
      if (!prim.texture) {
        prim.texture = loadTexture(prim.textureUrl);
      }
    }
    
    if (prim.hasBump) {
      if (!prim.bumpTexture) {
        prim.bumpTexture = loadTexture(prim.textureUrl); 
      }
    }
  }
  
  prim.children.forEach(child => initAllVAOs(child));
  prim.particles.forEach(part => {
    part.particles.forEach(child => {
      initAllVAOs(child.obj);
    })
  })
}
function deleteVAOs(prim) {
  if (prim.vao) {
    gl.deleteVertexArray(prim.vao);
    prim.vao = null;
  }
  if (prim.texture) {
    gl.deleteTexture(prim.texture);
    prim.texture = null;
  }
  if (prim.bumpTexture) {
    gl.deleteTexture(prim.bumpTexture);
    prim.bumpTexture = null;
  }
  prim.children.forEach(child => deleteVAOs(child));
  prim.particles.forEach(part => {
    part.particles.forEach(child => {
      deleteVAOs(child.obj);
    })
  })
}

  document.getElementById("restartBtn").addEventListener("click", () => {
      kartX = 0; kartZ = 0; kartAngle = 0; kartSpeed = 0;
      currentLevel = 1;
      gameTime = 45;
      freezeCar = false;

      globalObjects.forEach(obj => deleteVAOs(obj));
      deleteVAOs(kartBase);
      createScene(currentLevel);
      initAllVAOs(kartBase);
      globalObjects.forEach(obj => initAllVAOs(obj));
      maxballs = ballColliders.length;
      currentballs = maxballs;
      document.getElementById('levelCounter').textContent = `Level: ${currentLevel}`;
  });

  function updateTimer() {
  const now = Date.now();
  const elapsed = (now - lastTime) / 1000;
  
  if (elapsed >= 1&& gameTime > 0) {
    gameTime--;
    lastTime = now;
    document.getElementById('Timer').textContent = `Time: ${Math.round(gameTime)}s`;
    if (gameTime <= 0) {
      freezeCar = true;
    }
  }
}

    let modelViewMatrix;
    let lastFrame = Date.now();
    let renderTime = 0;

    function render() {
      renderTime = Date.now() - lastFrame;
      lastFrame = Date.now();
      document.getElementById('ballCounter').textContent = `Balls: ${currentballs}/${maxballs}`;
      updateTimer();

      // Update kart physics
      if (keys['ArrowUp']) {
        kartSpeed -= getAcceleration();
        wheelRotation -= 0.1;
        if(!onRoad) {
          partL.particles[0].isDisabled = false;
          partR.particles[0].isDisabled = false;
        }
        else if(onRoad && -kartSpeed < burnoutSpeed) {
          partL.particles[0].isDisabled = false;
          partR.particles[0].isDisabled = false;
        }
        else {
          partL.particles[0].isDisabled = true;
          partR.particles[0].isDisabled = true;
        }
      }
      if (keys['ArrowDown']) {
        kartSpeed += getAcceleration();
        wheelRotation += 0.1;
      }
      if(kartSpeed < 0.01 && !keys['ArrowUp']) {
          partL.particles[0].isDisabled = true;
          partR.particles[0].isDisabled = true;
      }

      kartSpeed = Math.max(-getMaxSpeed(), Math.min(getMaxSpeed(), kartSpeed));
      kartSpeed *= getFriction();

      if (Math.abs(kartSpeed) > 0.01) {

        let targetInput = 0;
        if (keys['ArrowLeft']) targetInput = -1;
        if (keys['ArrowRight']) targetInput = 1;
        if(kartSpeed > 0) targetInput *= -1;
        steeringInput += (targetInput - steeringInput) * 0.15;
        let speedFactor = Math.min(Math.abs(kartSpeed) / (maxSpeedRoad + 1), 1);
        let steerFalloff = 1.0 - speedFactor * speedFactor;

        let targetSteeringAngle = steeringInput * maxSteerAngle * steerFalloff;
        steeringAngle += (targetSteeringAngle - steeringAngle) * steerResponsiveness;
        kartAngle += steeringAngle * -.07;
        // if (keys['ArrowLeft']) kartAngle -= turnSpeed * (kartSpeed / getMaxSpeed());
        // if (keys['ArrowRight']) kartAngle += turnSpeed * (kartSpeed / getMaxSpeed());
      }
      wheelRL.rotY = kartSpeed + wheelRotation;
      wheelRR.rotY = kartSpeed + wheelRotation;
      wheelFR.rotY = kartSpeed + wheelRotation;
      wheelFL.rotY = kartSpeed + wheelRotation;

            if (keys['ArrowLeft'] && !keys['ArrowRight']) {
        isTurning = -1;
        axleFR.rotY = axleRotY + (axleTurnCoeff * turnSpeed);
        axleFL.rotY = axleRotY + (axleTurnCoeff * turnSpeed);
      }
      else if (keys['ArrowRight'] && !keys['ArrowLeft']) {
        isTurning = 1;
        axleFR.rotY = axleRotY - (axleTurnCoeff * turnSpeed);
        axleFL.rotY = axleRotY - (axleTurnCoeff * turnSpeed);
      }
      else {
        isTurning = 0;
        axleFR.rotY = axleRotY;
        axleFL.rotY = axleRotY;
      }

      kartX += Math.sin(kartAngle) * kartSpeed;
      kartZ += Math.cos(kartAngle) * kartSpeed;

      gl.enable(gl.DEPTH_TEST);
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

      let camZ = -kartZ - 13;
      let camX = -kartX + 0;
      modelViewMatrix = mat4Identity();


      modelViewMatrix = mat4Translate(modelViewMatrix, [0, -3, -13]);


      modelViewMatrix = mat4RotateY(modelViewMatrix, -kartAngle);

      modelViewMatrix = mat4Translate(modelViewMatrix, [-kartX, 0, -kartZ]);





      let deltaTime = Date.now() - startTime;

      gl.useProgram(program);
      gl.uniform1f(timeLoc, deltaTime / 1000.0);
      gl.uniformMatrix4fv(uPM, false, proj);
      gl.uniformMatrix4fv(uMVM, false, modelViewMatrix);



      let kartModel = mat4Identity();
      kartModel = mat4Translate(kartModel, [kartX, 0, kartZ]);
      kartModel = mat4RotateY(kartModel, kartAngle);

// Sun direction (e.g. shining downward and a bit from the side)
let sunDir = [0.4, -1.0, 0.3]; 
const sunIntensity = 4.0;
const sunColor = [1 * sunIntensity, .95 * sunIntensity, .9 * sunIntensity];
gl.uniform3fv(uLightDir, sunDir);
gl.uniform3fv(uLightColor, sunColor);

      drawPrimitive(kartBase, kartModel);

      for (let i = 0; i < globalObjects.length; i++) {
        let obj = globalObjects[i];
        drawPrimitive(obj);
      }

      for(let i = 0; i < bounceColliders.length; i++) {
        let col = bounceColliders[i];
        if(col.checkOverlap(kartBase.collider.points)) {
          kartSpeed = -kartSpeed * 1.8;
          //acceleration = 0;
        }
        else {
          //acceleration = 0.03;
        }
      }

      for(let i = 0; i < ballColliders.length; i++) {
        let col = ballColliders[i];
        if(col.checkOverlap(kartBase.collider.points)) {
          ballColliders.splice(i, 1);
          for(let j = globalObjects.length - 1; j >= 0; j--) {
            if(globalObjects[j].collider === col) {
              globalObjects.splice(j, 1);
              currentballs--;
              gameTime += ballValue;
              document.getElementById('Timer').textContent = `Time: ${Math.round(gameTime)}s`;
              break;
            }
          }

        }
      }

      for(let i = 0; i < roadColliders.length; i++) {
        let col = roadColliders[i]; 
        if(col.checkOverlap(kartBase.collider.points)) {
          onRoad = true;
          onMud = false; //road take priority
          partL.particles[0].primitiveCallback = makeParticleSmoke;
          partR.particles[0].primitiveCallback = makeParticleSmoke;
          break;
        }
        onRoad = false;
      }
      if (!onRoad) { //we can skip this if we already know we on the road
        for (let i = 0; i < mudColliders.length; i++) {
          let col = mudColliders[i];
          if (col.checkOverlap(kartBase.collider.points)) {
            onMud = true;
            partL.particles[0].primitiveCallback = makeParticleMud;
            partR.particles[0].primitiveCallback = makeParticleMud;
            break;
          }
          onMud = false;
        }
      }
      if(!onRoad && !onMud) {
          partL.particles[0].primitiveCallback = makeParticleGrass;
          partR.particles[0].primitiveCallback = makeParticleGrass;
      }

      for(let i = 0; i < speedColliders.length; i++) {
        let col = speedColliders[i];
      }

      // Draw all collider debug visualizations
      // drawColliderDebug(kartBase.collider, [0, 0, 1]); // Blue for kart
      // [bounceColliders, ballColliders, speedColliders, mudColliders, roadColliders].forEach(element => {
      //   for(let i = 0; i < element.length; i++) {
      //     drawColliderDebug(element[i], [0, 1, 0]); // Green for obstacles
      //   }
      // });

      if(currentballs == 0){
        kartX = 0; kartZ = 0; kartAngle = 0; kartSpeed = 0;
        currentLevel++;
        globalObjects.forEach(obj => deleteVAOs(obj));
        deleteVAOs(kartBase);
        createScene(currentLevel);
        initAllVAOs(kartBase);
        globalObjects.forEach(obj => initAllVAOs(obj));
        maxballs = ballColliders.length;
        currentballs = maxballs;
        document.getElementById('levelCounter').textContent = `Level: ${currentLevel}`;
        gameTime+= 20;
      }
    }

    window.onload = function () {
      initAllVAOs(kartBase);
      globalObjects.forEach(obj => initAllVAOs(obj));
      setInterval(render, 30);
    }

  </script>
</body>

</html>