<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <title>UNM CS 412/512 Final Project</title>
  <style>
    body {
      background: #111;
      color: #ccc;
      font-family: monospace;
    }

    textarea {
      background: #222;
      color: #0f0;
      font: 14px monospace;
      width: 400px;
      height: 250px;
    }

    canvas {
      border: 1px solid #444;
      background: #757474;

    }
  </style>
</head>

<body>
  <div style="display: flex; justify-content: center; gap: 10px; align-items: flex-start;">
    <div style="display: flex; justify-content: center; flex-direction: column; gap: 10px;">
    </div>
    <div>
      <canvas id="glcanvas" width="1200" height="800"></canvas>
    </div>
  </div>

  <!-- Vertex shader -->
  <script id="vertex-shader" type="x-shader/x-vertex">#version 300 es
precision mediump float;

in vec3 aPosition;
in vec3 aNormal;
in vec3 aColor;
in vec2 aTexCoord;

uniform mat4 uModelViewMatrix;
uniform mat4 uProjectionMatrix;
uniform mat4 uModelTransformationMatrix;
uniform mat3 uNormalMatrix;

out vec3 vColor;
out vec3 vNormal;
out vec3 vPosition;
out vec2 vTexCoord;

void main() {
    vec4 worldPos = uModelTransformationMatrix * vec4(aPosition, 1.0);

    gl_Position = uProjectionMatrix * uModelViewMatrix * worldPos;

    vColor = aColor;
    vNormal = normalize(uNormalMatrix * aNormal);
    vPosition = worldPos.xyz;
    vTexCoord = aTexCoord;
}
</script>
  <!-- Fragment Shader -->
  <script id="fragment-shader" type="x-shader/x-fragment">#version 300 es
precision mediump float;

in vec3 vColor;
in vec3 vNormal;
in vec3 vPosition;
in vec2 vTexCoord;

out vec4 fragColor;

// Light data
uniform vec3 uLightPos;
uniform vec3 uLightColor;

// Material data
uniform float uKAmbient;
uniform float uKDiffuse;
uniform float uKSpecular;
uniform float uShininess;

uniform sampler2D uTex;
uniform sampler2D uBumpTex;
uniform bool uUseBump;
uniform float uBumpStrength;
uniform bool uUseTexture;


void main() {
    vec3 N = normalize(vNormal);
    if (uUseBump) {
      float h  = texture(uBumpTex, vTexCoord).r;
      float hu = texture(uBumpTex, vTexCoord + vec2(0.01, 0.0)).r;
      float hv = texture(uBumpTex, vTexCoord + vec2(0.0, 0.01)).r;

    vec3 grad = vec3((h - hu) * uBumpStrength,
                    (h - hv) * uBumpStrength,
                    1.0);

      N = normalize(N + grad);
    }
    vec3 L = normalize(uLightPos - vPosition);
    vec3 V = normalize(-vPosition);
    vec3 R = reflect(-L, N);

    float diff = max(dot(N, L), 0.0);
    float spec = 0.0;

    if (diff > 0.0) {
        spec = pow(max(dot(R, V), 0.0), uShininess);
    }



    vec3 ambient  = uKAmbient  * vColor;
    vec3 diffuse  = uKDiffuse  * diff * vColor;
    vec3 specular = uKSpecular * spec * uLightColor;

    vec3 texColor = vec3(1.0);
    if (uUseTexture) {
        texColor = texture(uTex, vTexCoord).rgb;
    }


    vec3 result = (ambient + diffuse) * texColor + specular;
    fragColor = vec4(result, 1.0);
}
</script>
  <script src="utility.js"></script>
  <script src="collider.js"></script>
  <script src="primitives.js"></script>
  <script src="transformation.js"></script>
  <script src="sceneObjects.js"></script>

  <script>
    function createShader(gl, type, source) {
      let shader = gl.createShader(type);
      gl.shaderSource(shader, source);
      gl.compileShader(shader);
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        throw new Error(gl.getShaderInfoLog(shader));
      }
      return shader;
    }

    function createProgram(gl, vsSource, fsSource) {
      let vs = createShader(gl, gl.VERTEX_SHADER, vsSource);
      let fs = createShader(gl, gl.FRAGMENT_SHADER, fsSource);
      let prog = gl.createProgram();
      gl.attachShader(prog, vs);
      gl.attachShader(prog, fs);
      gl.linkProgram(prog);
      if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
        throw new Error(gl.getProgramInfoLog(prog));
      }
      return prog;
    }

    // WebGL setup
    const canvas = document.getElementById("glcanvas");
    const gl = canvas.getContext("webgl2");
    if (!gl) alert("WebGL2 not supported");



    let program, posLoc, colorLoc, normalLoc, texCoordLoc;
    let uMVM, uPM, uMTM, uNormalMatrix;
    let uLightPos, uViewPos;
    let uKAmbient, uKDiffuse, uKSpecular, uKShininess;
    let uUseTexture;
    let uUseBump, uBumpTex, uBumpStrength;

    let vbo, cbo, nbo, ibo;

    // Buffers
    function initBuffers() {
      vbo = gl.createBuffer();
      cbo = gl.createBuffer();
      nbo = gl.createBuffer();
      ibo = gl.createBuffer();
    }
    initBuffers();

    function initShaderProgram() {
      try {
        program = createProgram(gl, document.getElementById("vertex-shader").textContent, document.getElementById("fragment-shader").textContent);
        gl.useProgram(program);
        posLoc = gl.getAttribLocation(program, "aPosition");
        colorLoc = gl.getAttribLocation(program, "aColor");
        timeLoc = gl.getUniformLocation(program, "uTime");
        uMVM = gl.getUniformLocation(program, "uModelViewMatrix");
        uPM = gl.getUniformLocation(program, "uProjectionMatrix");
        uMTM = gl.getUniformLocation(program, "uModelTransformationMatrix");

        normalLoc = gl.getAttribLocation(program, "aNormal");
        texCoordLoc = gl.getAttribLocation(program, "aTexCoord");

        uNormalMatrix = gl.getUniformLocation(program, "uNormalMatrix");
        uLightPos = gl.getUniformLocation(program, "uLightPos");
        uViewPos = gl.getUniformLocation(program, "uViewPos");

        uKAmbient = gl.getUniformLocation(program, "uKAmbient");
        uKDiffuse = gl.getUniformLocation(program, "uKDiffuse");
        uKSpecular = gl.getUniformLocation(program, "uKSpecular");
        uShininess = gl.getUniformLocation(program, "uShininess");

        uUseTexture = gl.getUniformLocation(program, "uUseTexture");
        uUseBump = gl.getUniformLocation(program, "uUseBump");
        uBumpTex = gl.getUniformLocation(program, "uBumpTex");
        uBumpStrength = gl.getUniformLocation(program, "uBumpStrength");
        uTex = gl.getUniformLocation(program, "uTex");



      } catch (e) { console.error(e); }
    }
    initShaderProgram();


    // Kart physics
    let kartX = 0, kartZ = 0, kartAngle = 0, kartSpeed = 0;
    let maxSpeed = 1;
    let acceleration = 0.03;
    const friction = 0.97;
    const turnSpeed = 0.05;
    let isTurning = 0;
    const axleRotY = axleFR.rotY;
    const axleTurnCoeff = 3.0;

    // Keyboard
    let keys = {};
    document.addEventListener('keydown', e => {
      keys[e.key] = true;
      if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) e.preventDefault();
    });
    document.addEventListener('keyup', e => keys[e.key] = false);

    let fov = Math.PI / 4, aspect = canvas.width / canvas.height, zNear = 0.1, zFar = 1000;
    let f = 1 / Math.tan(fov / 2);
    let proj = new Float32Array([
      f / aspect, 0, 0, 0, 0, f, 0, 0, 0, 0, (zFar + zNear) / (zNear - zFar), -1, 0, 0, (2 * zFar * zNear) / (zNear - zFar), 0
    ]);

    let startTime = Date.now();

    function loadTexture(url) {
      const texture = gl.createTexture();
      
      const image = new Image();
      image.crossOrigin = "anonymous";
      image.onload = () => {
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
        gl.generateMipmap(gl.TEXTURE_2D);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
      };
      image.src = url;

      return texture;
    }

function drawPrimitive(prim, transform = null) {
  let T = mat4Translate(mat4Identity(), [prim.posX, prim.posY, prim.posZ]);
  let R = prim.getRotationMatrix();
  let S = mat4Scale(mat4Identity(), [prim.scaX, prim.scaY, prim.scaZ]);
  let localTransform = multiplyMat4(multiplyMat4(T, R), S);
  transform = transform ?? mat4Identity();
  transform = multiplyMat4(transform, localTransform);
  
  if (prim.collider) {
    prim.collider.updateParentTransform(transform);
  }


  gl.bindVertexArray(prim.vao);
  


  gl.uniformMatrix4fv(uMTM, false, transform);
  
  let normalMatrix = mat3FromMat4(transform);
  normalMatrix = mat3InvertTranspose(normalMatrix);
  gl.uniformMatrix3fv(uNormalMatrix, false, normalMatrix);

  gl.uniform1f(uKAmbient, prim.kAmbient);
  gl.uniform1f(uKDiffuse, prim.kDiffuse);
  gl.uniform1f(uKSpecular, prim.kSpecular);
  gl.uniform1f(uShininess, prim.shininess);

  if (prim.hasTexture) {
    if (!prim.texture)
      prim.texture = loadTexture(prim.textureUrl);
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, prim.texture);
    gl.uniform1i(uUseTexture, 1);
    gl.uniform1i(uTex, 0);
  } else {
    gl.uniform1i(uUseTexture, 0);
  }

  if (prim.hasBump) {
    if (!prim.bumpTexture)
      prim.bumpTexture = loadTexture(prim.bumpTextureUrl);
    gl.activeTexture(gl.TEXTURE1);
    gl.bindTexture(gl.TEXTURE_2D, prim.bumpTexture);
    gl.uniform1i(uUseBump, 1);
    gl.uniform1i(uBumpTex, 1);
    gl.uniform1f(uBumpStrength, prim.bumpStrength);
  } else {
    gl.uniform1i(uUseBump, 0);
  }

  gl.drawElements(gl.TRIANGLES, prim.indices.length, gl.UNSIGNED_SHORT, 0);

  prim.children.forEach(child => drawPrimitive(child, transform));
}
    let wheelRotation = 0;


    function createVAO(prim) {
  const vao = gl.createVertexArray();
  gl.bindVertexArray(vao);

  // Position buffer
  const posBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, posBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, prim.positions, gl.STATIC_DRAW);
  gl.enableVertexAttribArray(posLoc);
  gl.vertexAttribPointer(posLoc, 3, gl.FLOAT, false, 0, 0);

  // Normal buffer
  const normalBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, prim.normals, gl.STATIC_DRAW);
  gl.enableVertexAttribArray(normalLoc);
  gl.vertexAttribPointer(normalLoc, 3, gl.FLOAT, false, 0, 0);

  // Color buffer
  const colorBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, prim.colors, gl.STATIC_DRAW);
  gl.enableVertexAttribArray(colorLoc);
  gl.vertexAttribPointer(colorLoc, 3, gl.FLOAT, false, 0, 0);

  // Texture coordinates
  if (prim.hasTexture||prim.hasBump) {
    const texBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, texBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, prim.texCoords, gl.STATIC_DRAW);
    gl.enableVertexAttribArray(texCoordLoc);
    gl.vertexAttribPointer(texCoordLoc, 2, gl.FLOAT, false, 0, 0);
  }
  // Index buffer
  const indexBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, prim.indices, gl.STATIC_DRAW);

  gl.bindVertexArray(null);
  
  return vao;
}

function initAllVAOs(prim) {
  if (!prim.vao) {
    prim.vao = createVAO(prim);
    
if (prim.hasTexture) {
      if (!prim.texture) {
        prim.texture = loadTexture(prim.textureUrl);
      }
    }
    
    if (prim.hasBump) {
      if (!prim.bumpTexture) {
        prim.bumpTexture = loadTexture(prim.textureUrl); 
      }
    }
  }
  
  prim.children.forEach(child => initAllVAOs(child));
}
    function render() {

      // Update kart physics
      if (keys['ArrowUp']) {
        kartSpeed -= acceleration;
        wheelRotation -= 0.1;
      }
      if (keys['ArrowDown']) {
        kartSpeed += acceleration;
        wheelRotation += 0.1;
      }
      kartSpeed = Math.max(-maxSpeed, Math.min(maxSpeed, kartSpeed));
      kartSpeed *= friction;

      if (Math.abs(kartSpeed) > 0.01) {
        if (keys['ArrowLeft']) kartAngle -= turnSpeed * (kartSpeed / maxSpeed);
        if (keys['ArrowRight']) kartAngle += turnSpeed * (kartSpeed / maxSpeed);
      }
      wheelRL.rotY = kartSpeed + wheelRotation;
      wheelRR.rotY = kartSpeed + wheelRotation;
      wheelFR.rotY = kartSpeed + wheelRotation;
      wheelFL.rotY = kartSpeed + wheelRotation;

      if (keys['ArrowLeft'] && !keys['ArrowRight']) {
        isTurning = -1;
        axleFR.rotY = axleRotY + (axleTurnCoeff * turnSpeed);
        axleFL.rotY = axleRotY + (axleTurnCoeff * turnSpeed);
      }
      else if (keys['ArrowRight'] && !keys['ArrowLeft']) {
        isTurning = 1;
        axleFR.rotY = axleRotY - (axleTurnCoeff * turnSpeed);
        axleFL.rotY = axleRotY - (axleTurnCoeff * turnSpeed);
      }
      else {
        isTurning = 0;
        axleFR.rotY = axleRotY;
        axleFL.rotY = axleRotY;
      }


      kartX += Math.sin(kartAngle) * kartSpeed;
      kartZ += Math.cos(kartAngle) * kartSpeed;

      gl.enable(gl.DEPTH_TEST);
      //gl.clearColor(0, 0, 0, 1);
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

      let camZ = -kartZ - 13;
      let camX = -kartX + 0;
      let modelViewMatrix = mat4Identity();


      modelViewMatrix = mat4Translate(modelViewMatrix, [0, -3, -13]);


      modelViewMatrix = mat4RotateY(modelViewMatrix, -kartAngle);

      modelViewMatrix = mat4Translate(modelViewMatrix, [-kartX, 0, -kartZ]);





      let deltaTime = Date.now() - startTime;

      gl.uniform1f(timeLoc, deltaTime / 1000.0);
      gl.uniformMatrix4fv(uPM, false, proj);
      gl.uniformMatrix4fv(uMVM, false, modelViewMatrix);



      let kartModel = mat4Identity();
      kartModel = mat4Translate(kartModel, [kartX, 0, kartZ]);
      kartModel = mat4RotateY(kartModel, kartAngle);

      gl.uniform3fv(uLightPos, [5, 10, 50]);       // simple overhead light
      gl.uniform3fv(uViewPos, [0, 3, 13]);        // approximated camera position

      drawPrimitive(kartBase, kartModel);

      for (let i = 0; i < globalObjects.length; i++) {
        let obj = globalObjects[i];
        drawPrimitive(obj);
      }

      for(let i = 0; i < globalColliders.length; i++) {
        let col = globalColliders[i];
        if(col.checkOverlap(kartBase.collider.points)) {
          kartSpeed = -kartSpeed * 1.8;
          acceleration = 0;
        }
        else {
          acceleration = 0.03;
        }
      }

    }

    window.onload = function () {
      initAllVAOs(kartBase);
      globalObjects.forEach(obj => initAllVAOs(obj));
      setInterval(render, 30);
    }

  </script>
</body>

</html>